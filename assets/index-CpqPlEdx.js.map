{"version":3,"file":"index-CpqPlEdx.js","sources":["../../src/domUtils.ts","../../src/puzzleLogic.ts","../../src/astar.ts","../../src/gameUI.ts","../../src/main.ts"],"sourcesContent":["\n\n/**\n * Executes a callback function once the DOM is fully loaded and parsed.\n * If the DOM is already loaded, the callback is executed asynchronously via `setTimeout`.\n * @param fn The function to call once the DOM is ready.\n */\nexport function onDocumentReady(fn: () => void): void {\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', fn);\n    } else {\n        // If the DOM is already loaded, execute the function immediately,\n        // but use setTimeout to ensure it runs asynchronously like DOMContentLoaded,\n        // preventing potential race conditions or unexpected synchronous execution.\n        setTimeout(fn, 0);\n    }\n}\n\n/**\n * A generic query selector function that optionally takes a type parameter for the returned element.\n * @template T The type of the HTMLElement to be returned. Defaults to HTMLElement.\n * @param selector The CSS selector string.\n * @returns The first element matching the selector, or `null` if no match is found. Typed as T or null.\n */\nexport function qs<T extends HTMLElement = HTMLElement>(selector: string): T | null {\n    return document.querySelector(selector) as T | null;\n}\n\n/**\n * A generic query selector all function that optionally takes a type parameter for the returned elements.\n * @template T The type of the HTMLElement to be returned in the NodeListOf. Defaults to HTMLElement.\n * @param selector The CSS selector string.\n * @returns A static NodeListOf<T> containing all elements matching the selector.\n */\nexport function qsa<T extends HTMLElement = HTMLElement>(selector: string): NodeListOf<T> {\n    return document.querySelectorAll(selector) as NodeListOf<T>;\n}\n","import type { BoardState, PosMap } from './types';\n\n/** The total number of squares on the puzzle board (e.g., 9 for a 3x3 grid). */\nexport const NUM_SQUARES: number = 9;\n\n/** The number of actual puzzle pieces (excluding the empty square). */\nexport const NUM_PIECES: number = NUM_SQUARES - 1;\n\n/**\n * The target configuration of the puzzle board representing the solved state.\n * The empty square is represented by `0`. Values are 1-indexed tile numbers,\n * and their positions in the array are 0-indexed.\n */\nexport const GOAL_STATE: BoardState = [1, 2, 3, 4, 5, 6, 7, 8, 0];\n\n/**\n * Adjacency list for the squares on the puzzle board.\n * Keys are 1-indexed square numbers. Values are arrays of 1-indexed square numbers\n * that are adjacent (i.e., a piece can move from an adjacent square into the key square if it's empty).\n */\nexport const POS_ADJACENCY: PosMap = {\n  1: [2, 4], 2: [1, 3, 5], 3: [2, 6],\n  4: [1, 7, 5], 5: [2, 4, 6, 8], 6: [3, 5, 9],\n  7: [4, 8], 8: [7, 5, 9], 9: [8, 6]\n};\n\n/**\n * Checks if the provided board state matches the {@link GOAL_STATE}.\n * @param boardState The current state of the board, as a `BoardState` array.\n * @returns `true` if the board is solved, `false` otherwise.\n */\nexport function isSolved(boardState: BoardState): boolean {\n  if (boardState.length !== GOAL_STATE.length) return false;\n  for (let i = 0; i < GOAL_STATE.length; i++) {\n    if (boardState[i] !== GOAL_STATE[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Applies a move to a given board state and returns a new board state representing the result.\n * This function does not mutate the original `currentBoardState`.\n * The tile at `pieceToMoveIndex` is swapped with the empty space (0) at `targetEmptyIndex`.\n * @param currentBoardState The current state of the board before the move.\n * @param pieceToMoveIndex The 0-indexed board position of the piece that is intended to be moved.\n * @param targetEmptyIndex The 0-indexed board position of the empty square where the piece will move.\n * @returns A new `BoardState` array representing the board after the move.\n *          If the move is invalid (e.g., target is not empty, piece is null),\n *          it logs an error and returns a copy of the original board state.\n * @throws Will not throw an error directly but logs to console on invalid move.\n *         Consider stricter error handling if necessary for the application.\n */\nexport function applyMove(\n  currentBoardState: BoardState,\n  pieceToMoveIndex: number,\n  targetEmptyIndex: number\n): BoardState {\n  const newBoardState = [...currentBoardState]; // Create a copy to ensure immutability\n  const tileValue = newBoardState[pieceToMoveIndex];\n\n  // Validate the move\n  if (tileValue === null) {\n    console.error(\n        \"Invalid move: Attempted to move a 'null' tile.\",\n        { currentBoardState, pieceToMoveIndex, targetEmptyIndex }\n    );\n    return newBoardState; // Return original state copy on error\n  }\n  if (newBoardState[targetEmptyIndex] !== 0) {\n    console.error(\n        \"Invalid move: Target square is not empty.\",\n        { currentBoardState, pieceToMoveIndex, targetEmptyIndex, targetValue: newBoardState[targetEmptyIndex] }\n    );\n    return newBoardState; // Return original state copy on error\n  }\n\n  // Perform the swap\n  newBoardState[targetEmptyIndex] = tileValue;\n  newBoardState[pieceToMoveIndex] = 0; // The piece's original spot becomes empty\n\n  return newBoardState;\n}\n\n/**\n * Converts a 0-indexed board array index to its corresponding 1-indexed square number.\n * This is useful when relating board array positions to UI elements or `POS_ADJACENCY` keys.\n * @param index0 The 0-indexed position in the `BoardState` array.\n * @returns The corresponding 1-indexed square number (e.g., index 0 maps to square 1).\n */\nexport function getSquareNumberFromIndex(index0: number): number {\n    return index0 + 1;\n}\n\n/**\n * Converts a 1-indexed square number to its corresponding 0-indexed board array index.\n * This is useful for accessing elements within the `BoardState` array using a square number.\n * @param squareNumber1 The 1-indexed square number (e.g., as used in UI or `POS_ADJACENCY`).\n * @returns The corresponding 0-indexed position in the `BoardState` array (e.g., square 1 maps to index 0).\n */\nexport function getIndexFromSquareNumber(squareNumber1: number): number {\n    return squareNumber1 - 1;\n}\n","import type { BoardState, SearchNode, SearchNodeAction, PosMap } from './types';\nimport { GOAL_STATE, NUM_SQUARES, getSquareNumberFromIndex, getIndexFromSquareNumber } from './puzzleLogic';\n\n/**\n * Calculates the Manhattan distance heuristic for a given board state.\n * The Manhattan distance is the sum of the distances of each tile\n * from its goal position.\n * @param boardState The current configuration of the puzzle board.\n * @param goalState The target configuration of the puzzle board (usually {@link GOAL_STATE}).\n * @param numSquares The total number of squares in the puzzle (e.g., 9 for an 8-puzzle).\n * @returns The total Manhattan distance for the given board state.\n */\nexport function getManhattanDistance(\n  boardState: BoardState,\n  goalState: BoardState,\n  numSquares: number\n): number {\n  let totalDistance: number = 0;\n  const dimension: number = Math.sqrt(numSquares);\n\n  if (dimension !== Math.floor(dimension)) {\n    console.error(\"numSquares must be a perfect square for Manhattan distance calculation.\");\n    return Infinity; // Or throw error\n  }\n\n  for (let i = 0; i < boardState.length; i++) {\n    const tileValue: number | null = boardState[i];\n    // Only calculate distance for actual tiles, not the empty space (0) or nulls\n    if (tileValue !== 0 && tileValue !== null) {\n      const currentRow: number = Math.floor(i / dimension);\n      const currentCol: number = i % dimension;\n\n      const targetIndex: number = goalState.indexOf(tileValue);\n      if (targetIndex === -1) {\n        // This case should ideally not happen if boardState and goalState are valid\n        console.warn(`Tile value ${tileValue} not found in goal state during Manhattan calculation.`);\n        continue;\n      }\n      const targetRow: number = Math.floor(targetIndex / dimension);\n      const targetCol: number = targetIndex % dimension;\n\n      totalDistance += Math.abs(currentRow - targetRow) + Math.abs(currentCol - targetCol);\n    }\n  }\n  return totalDistance;\n}\n\n/**\n * Internal helper function to create {@link SearchNode} objects for the A* algorithm.\n * @param state The board state for this node.\n * @param parent The parent node in the search tree, or `null` for the start node.\n * @param action The action taken to reach this state from the parent, or `null` for the start node.\n * @param g The cost from the start node to this node (depth).\n * @param h The heuristic estimate (Manhattan distance) from this node to the goal.\n * @returns A new {@link SearchNode} object.\n */\nfunction _createSearchNode(\n  state: BoardState,\n  parent: SearchNode | null,\n  action: SearchNodeAction | null,\n  g: number,\n  h: number\n): SearchNode {\n  return { state, parent, action, g, h, f: g + h };\n}\n\n/**\n * Internal helper function to compare two board state arrays for equality.\n * @param arr1 The first board state array.\n * @param arr2 The second board state array.\n * @returns `true` if the arrays are identical, `false` otherwise.\n */\nfunction areArraysEqual(arr1: BoardState, arr2: BoardState): boolean {\n  if (arr1.length !== arr2.length) return false;\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) return false;\n  }\n  return true;\n}\n\n/**\n * Internal helper function to reconstruct the path of actions from the start node to the goal node.\n * It traverses backwards from the goal node using parent references.\n * @param node The goal {@link SearchNode} from which to reconstruct the path.\n * @returns An array of {@link SearchNodeAction} objects representing the sequence of moves.\n */\nfunction reconstructPath(node: SearchNode): SearchNodeAction[] {\n  const path: SearchNodeAction[] = [];\n  let currentNode: SearchNode | null = node;\n  while (currentNode && currentNode.parent) { // Ensure currentNode and its parent are not null\n    if (currentNode.action) { // Ensure action is not null\n      path.unshift(currentNode.action);\n    }\n    currentNode = currentNode.parent;\n  }\n  return path;\n}\n\n/**\n * Checks if a board configuration is solvable for the 8-puzzle.\n * For a 3x3 puzzle, a configuration is solvable if and only if \n * the number of inversions is even (when the blank space is ignored).\n * An inversion is when a larger numbered tile appears before a smaller numbered tile\n * when reading the board from left to right, top to bottom (excluding the blank).\n * @param boardState The board configuration to check.\n * @returns `true` if the board is solvable, `false` otherwise.\n */\nfunction isSolvable(boardState: BoardState): boolean {\n  // Extract only the numbered tiles (exclude 0 and null)\n  const tiles: number[] = boardState.filter(tile => tile !== 0 && tile !== null) as number[];\n  \n  // Count inversions\n  let inversions = 0;\n  for (let i = 0; i < tiles.length; i++) {\n    for (let j = i + 1; j < tiles.length; j++) {\n      if (tiles[i] > tiles[j]) {\n        inversions++;\n      }\n    }\n  }\n  \n  // For a 3x3 puzzle, configuration is solvable if inversions are even\n  return inversions % 2 === 0;\n}\n\n/**\n * Performs an A* search to find the optimal sequence of moves to solve the puzzle.\n * @param initialState The starting configuration of the puzzle board ({@link BoardState}).\n * @param adjacencyMap A {@link PosMap} defining the adjacency of squares, used to generate valid moves.\n * @returns An array of {@link SearchNodeAction} objects representing the solution path.\n *          Returns an empty array if the `initialState` is already the {@link GOAL_STATE}.\n *          Returns `null` if no solution path is found.\n */\nexport function performAStarSearch(\n  initialState: BoardState,\n  adjacencyMap: PosMap\n): SearchNodeAction[] | null {\n  if (areArraysEqual(initialState, GOAL_STATE)) {\n    return []; // Already solved\n  }\n\n  // Check if the initial state is solvable\n  if (!isSolvable(initialState)) {\n    return null; // Board configuration is unsolvable\n  }\n\n  const startNode: SearchNode = _createSearchNode(\n    initialState,\n    null,\n    null,\n    0,\n    getManhattanDistance(initialState, GOAL_STATE, NUM_SQUARES)\n  );\n\n  // The openSet stores nodes to be evaluated, prioritized by their f-score.\n  const openSet: SearchNode[] = [startNode];\n  // The closedSet stores states that have already been evaluated, to prevent cycles and redundant work.\n  // States are stored as strings for efficient Set lookups.\n  const closedSet: Set<string> = new Set();\n  closedSet.add(initialState.toString());\n\n  // Add iteration limit as safety measure\n  const MAX_ITERATIONS = 100000; // Reasonable limit for 8-puzzle\n  let iterations = 0;\n\n  while (openSet.length > 0 && iterations < MAX_ITERATIONS) {\n    iterations++;\n    // Simple array sort acts as a basic priority queue (less efficient for large sets).\n    openSet.sort((a, b) => a.f - b.f);\n    const currentNode: SearchNode | undefined = openSet.shift(); // Get node with the lowest f-score\n\n    if (!currentNode) {\n      // This should not be reached if openSet.length > 0, but it satisfies TypeScript's strict null checks.\n      return null;\n    }\n\n    // Goal check\n    if (areArraysEqual(currentNode.state, GOAL_STATE)) {\n      return reconstructPath(currentNode);\n    }\n\n    // Find the empty square (tile '0') to generate successor states\n    const emptyIdx: number = currentNode.state.indexOf(0);\n    if (emptyIdx === -1) {\n      console.error(\"A* Search Error: No empty square (0) found in the current state:\", currentNode.state);\n      return null; // Invalid state, should not occur\n    }\n\n    const emptySquareNumber: number = getSquareNumberFromIndex(emptyIdx); // 1-indexed for adjacencyMap\n    const movablePieceSquareNumbers: number[] | undefined = adjacencyMap[emptySquareNumber];\n\n    if (!movablePieceSquareNumbers) {\n      console.error(`A* Search Error: No adjacency information found for square number ${emptySquareNumber}.`);\n      continue; // Skip this node if adjacency info is missing\n    }\n\n    for (const movablePieceSquareNum of movablePieceSquareNumbers) {\n      const pieceToMoveIndex: number = getIndexFromSquareNumber(movablePieceSquareNum); // 0-indexed for board state\n\n      const tileValueMoved: number | null = currentNode.state[pieceToMoveIndex];\n      if (tileValueMoved === null) {\n        // This should not happen in a valid board state where only 0 is potentially \"empty\"\n        console.warn(`A* Search Warning: Attempted to move a null tile from index ${pieceToMoveIndex}.`);\n        continue;\n      }\n\n      // Create a new board state by applying the move\n      const neighborState: BoardState = [...currentNode.state];\n      neighborState[emptyIdx] = tileValueMoved;       // Move tile to the empty spot\n      neighborState[pieceToMoveIndex] = 0;            // Old spot of the tile becomes empty\n\n      const neighborStateStr: string = neighborState.toString();\n      if (closedSet.has(neighborStateStr)) {\n        continue; // Already evaluated this state\n      }\n\n      const gScore: number = currentNode.g + 1; // Cost to reach this neighbor\n      const hScore: number = getManhattanDistance(neighborState, GOAL_STATE, NUM_SQUARES);\n      const fScore: number = gScore + hScore;\n\n      // Check if a node with this state is already in the openSet with a lower f-score\n      let existingNodeInOpenSetIndex: number = -1;\n      for (let i = 0; i < openSet.length; i++) {\n          const openNode = openSet[i]; // Type guard for openSet[i]\n          if (openNode && areArraysEqual(openNode.state, neighborState)) {\n              existingNodeInOpenSetIndex = i;\n              break;\n          }\n      }\n\n      if (existingNodeInOpenSetIndex !== -1) {\n          const existingNode = openSet[existingNodeInOpenSetIndex]; // Type guard\n          if (existingNode && existingNode.f <= fScore) {\n              continue; // Found existing node with better or equal f-score\n          } else {\n              // This path is better; remove the old node from openSet\n              openSet.splice(existingNodeInOpenSetIndex, 1);\n          }\n      }\n\n      const action: SearchNodeAction = {\n        tileValue: tileValueMoved,\n        fromIndex: pieceToMoveIndex,\n        toIndex: emptyIdx\n      };\n      const neighborNode: SearchNode = _createSearchNode(neighborState, currentNode, action, gScore, hScore);\n\n      openSet.push(neighborNode);\n      closedSet.add(neighborStateStr); // Add to closedSet when it's scheduled for evaluation\n    }\n  }\n\n  if (iterations >= MAX_ITERATIONS) {\n    console.warn(`A* search reached maximum iterations (${MAX_ITERATIONS}) without finding a solution.`);\n  }\n\n  return null; // No solution found\n}\n","import { qs, qsa } from './domUtils';\nimport type { BoardState, SearchNodeAction } from './types';\nimport { POS_ADJACENCY, NUM_SQUARES, isSolved as isBoardSolved, getIndexFromSquareNumber, getSquareNumberFromIndex } from './puzzleLogic';\nimport { performAStarSearch } from './astar';\n\n/**\n * Manages the user interface, game state interactions, and event handling for the 8-puzzle game.\n */\nexport class GameUIController {\n    /** The CSS selector ID for the currently empty square (e.g., '#sq-9'). */\n    private freeSquareId: string;\n    /** Tracks the number of moves made by the player. */\n    private currentMoves: number = 0;\n    /** Stores the sequence of actions for the bot's solution animation. */\n    private solutionActions: SearchNodeAction[] = [];\n    /** Bound event handler for square click events to ensure correct `this` context. */\n    private readonly boundHandleSquareClick: (event: Event) => Promise<void>;\n\n\n\n    // DOM Element references\n    private readonly mixButton: HTMLButtonElement | null;\n    private readonly solveButton: HTMLButtonElement | null;\n    private readonly movesInput: HTMLInputElement | null;\n    private readonly movesNumArea: HTMLParagraphElement | null;\n    private readonly botMessageArea: HTMLParagraphElement | null;\n    private readonly gameArea: HTMLDivElement | null;\n    private readonly squares: NodeListOf<HTMLLIElement>;\n    private readonly animationDuration: number = 300;\n\n    constructor() {\n        this.mixButton = qs<HTMLButtonElement>(\"#mix\");\n        this.solveButton = qs<HTMLButtonElement>(\"#solve\");\n        this.movesInput = qs<HTMLInputElement>(\"#moves\");\n        this.movesNumArea = qs<HTMLParagraphElement>(\"#moves_num\");\n        this.botMessageArea = qs<HTMLParagraphElement>(\"#bot_message\");\n        this.gameArea = qs<HTMLDivElement>('.game');\n        this.squares = qsa<HTMLLIElement>(\".square\");\n\n        if (!this.gameArea || this.squares.length !== NUM_SQUARES) {\n            console.error(\"Critical game elements (.game area or .square) not found or incorrect count in the DOM.\");\n        }\n\n        this.freeSquareId = this.findInitialFreeSquareIdSafe();\n        this.boundHandleSquareClick = this.handleSquareClick.bind(this);\n        this.init();\n    }\n\n    private init(): void {\n        this.bindSquareClicks();\n\n        this.mixButton?.addEventListener(\"click\", this.handleMixClick.bind(this));\n        this.solveButton?.addEventListener(\"click\", this.handleSolveClick.bind(this));\n        this.updateMovesCounter(0, 'Player');\n    }\n\n    private findInitialFreeSquareIdSafe(): string {\n        for (const square of Array.from(this.squares)) {\n            if (square.classList.contains('free')) return `#${square.id}`;\n        }\n        const lastSquareSelector = `#sq-${NUM_SQUARES}`;\n        const lastSquareElement = qs<HTMLLIElement>(lastSquareSelector);\n        if (lastSquareElement) {\n            console.warn(`No square initially had 'free' class. Defaulting to ${lastSquareSelector}.`);\n            lastSquareElement.classList.add('free');\n            return lastSquareSelector;\n        }\n        console.error(`Cannot find last square (#sq-${NUM_SQUARES}). Defaulting to #sq-9.`);\n        qs<HTMLLIElement>(\"#sq-9\")?.classList.add(\"free\");\n        return '#sq-9';\n    }\n\n    private bindSquareClicks(): void {\n        this.squares.forEach(square => {\n            square.removeEventListener(\"click\", this.boundHandleSquareClick);\n            square.addEventListener(\"click\", this.boundHandleSquareClick);\n        });\n    }\n\n\n\n    private toggleSquareInteraction(disabled: boolean): void {\n        this.squares.forEach(square => {\n            if (disabled) {\n                square.removeEventListener(\"click\", this.boundHandleSquareClick);\n            } else {\n                square.removeEventListener(\"click\", this.boundHandleSquareClick);\n                square.addEventListener(\"click\", this.boundHandleSquareClick);\n            }\n        });\n    }\n\n\n\n    private async handleMoveLogic(sourceSquareDomId: string, targetSquareDomId: string): Promise<void> {\n        this.toggleSquareInteraction(true);\n        this.toggleControlButtons(true);\n\n        await this.movePieceOnDOM(sourceSquareDomId, targetSquareDomId);\n\n        this.currentMoves++;\n        this.updateMovesCounter(this.currentMoves, 'Player');\n\n        const currentBoardState = this.getBoardStateFromDOM();\n        if (isBoardSolved(currentBoardState)) {\n            this.displayMessage(\"Congratulations! You solved it!\", \"success\");\n            await this.triggerWinAnimation();\n        } else {\n            this.toggleSquareInteraction(false);\n            this.toggleControlButtons(false);\n        }\n    }\n\n    private toggleControlButtons(disabled: boolean): void {\n        if (this.mixButton) this.mixButton.disabled = disabled;\n        if (this.solveButton) this.solveButton.disabled = disabled;\n    }\n\n    private displayMessage(text: string, _type: 'info' | 'error' | 'success' = 'info'): void {\n        if (this.botMessageArea) this.botMessageArea.textContent = text;\n        else console.warn(\"Bot message area not found. Message:\", text);\n    }\n\n    private updateMovesCounter(count: number | null, context: 'Player' | 'Bot' | 'Mix'): void {\n        if (this.movesNumArea) {\n            if (count === null) this.movesNumArea.textContent = \"\";\n            else this.movesNumArea.textContent = `# of moves: ${count} (${context})`;\n        }\n        if (context !== 'Bot') this.currentMoves = count ?? 0;\n    }\n\n    private movePieceOnDOM(pieceSquareIdToMove: string, targetFreeSquareId: string): Promise<void> {\n        const movingSquareEl = qs<HTMLLIElement>(pieceSquareIdToMove);\n        const targetSquareEl = qs<HTMLLIElement>(targetFreeSquareId);\n\n        if (!movingSquareEl || !targetSquareEl) {\n            console.error('Cannot find squares for animation', { pieceSquareIdToMove, targetFreeSquareId });\n            return Promise.resolve();\n        }\n        const movingPieceContentEl = movingSquareEl.firstElementChild as HTMLElement | null;\n        if (!movingPieceContentEl) {\n            console.error('Moving square has no piece content', { pieceSquareIdToMove });\n            return Promise.resolve();\n        }\n\n        return new Promise(resolve => {\n            const movingRect = movingSquareEl.getBoundingClientRect();\n            const targetRect = targetSquareEl.getBoundingClientRect();\n            const dx = targetRect.left - movingRect.left;\n            const dy = targetRect.top - movingRect.top;\n\n            movingSquareEl.style.zIndex = '100';\n            movingSquareEl.style.transform = `translateX(${dx}px) translateY(${dy}px) translateZ(25px)`;\n\n            const onTransitionEnd = (event: TransitionEvent) => {\n                if (event.propertyName !== 'transform' || event.target !== movingSquareEl) return;\n                movingSquareEl.removeEventListener('transitionend', onTransitionEnd);\n                movingSquareEl.style.transition = 'none';\n                movingSquareEl.style.transform = 'translateZ(5px)';\n                movingSquareEl.style.zIndex = '';\n                void movingSquareEl.offsetHeight;\n\n                targetSquareEl.appendChild(movingPieceContentEl);\n                movingSquareEl.classList.add('free');\n                targetSquareEl.classList.remove('free');\n                this.freeSquareId = `#${movingSquareEl.id}`;\n\n                setTimeout(() => { movingSquareEl.style.transition = ''; }, 0);\n                resolve();\n            };\n            movingSquareEl.addEventListener('transitionend', onTransitionEnd);\n        });\n    }\n\n    private async handleSquareClick(event: Event): Promise<void> {\n        const clickedSquareElement = event.currentTarget as HTMLLIElement | null;\n        if (!clickedSquareElement?.id || clickedSquareElement.classList.contains('free')) return;\n\n        const clickedSquareIdNumStr = clickedSquareElement.id.split('-')[1];\n        const freeSquareIdNumStr = this.freeSquareId.startsWith('#sq-') ? this.freeSquareId.substring(4) : null;\n        if (!clickedSquareIdNumStr || !freeSquareIdNumStr) return;\n\n        const clickedSquareIdNum = parseInt(clickedSquareIdNumStr, 10);\n        const freeSquareIdNum = parseInt(freeSquareIdNumStr, 10);\n\n        if (POS_ADJACENCY[clickedSquareIdNum]?.includes(freeSquareIdNum)) {\n            await this.handleMoveLogic(`#${clickedSquareElement.id}`, this.freeSquareId);\n        }\n    }\n\n    private async triggerWinAnimation(): Promise<void> {\n        this.squares.forEach(squareLi => {\n            if (!squareLi.classList.contains('free')) {\n                const pieceDiv = squareLi.firstElementChild as HTMLElement | null;\n                if (pieceDiv) pieceDiv.classList.add('success');\n            }\n        });\n        if (this.botMessageArea) {\n            this.botMessageArea.innerHTML = '<h1>Congratulations!!!</h1><button id=\"play_again\" class=\"btn\">Play Again</button>';\n            this.botMessageArea.classList.add('win-display');\n            this.botMessageArea.style.display = 'block';\n            this.botMessageArea.querySelector<HTMLButtonElement>('#play_again')?.addEventListener('click', () => window.location.reload());\n        }\n        this.toggleSquareInteraction(true);\n        this.toggleControlButtons(true);\n    }\n\n    private getBoardStateFromDOM(): BoardState {\n        const boardState: BoardState = [];\n        for (let i = 1; i <= NUM_SQUARES; i++) {\n            const squareSelector = `#sq-${i}`;\n            if (squareSelector === this.freeSquareId) {\n                boardState.push(0);\n            } else {\n                const pieceElement = qs<HTMLLIElement>(squareSelector)?.firstElementChild as HTMLElement | undefined;\n                if (pieceElement?.id) {\n                    const pieceNumStr = pieceElement.id.split('-')[1];\n                    if (pieceNumStr) boardState.push(parseInt(pieceNumStr, 10));\n                    else { console.warn(`Malformed piece ID '${pieceElement.id}'`); boardState.push(null); }\n                } else { console.warn(`No valid piece in ${squareSelector}.`); boardState.push(null); }\n            }\n        }\n        return boardState;\n    }\n\n    private handleMixClick(): void {\n        let movesToMake = 1000;\n        if (this.movesInput?.value) {\n            const parsedVal = parseInt(this.movesInput.value, 10);\n            if (!isNaN(parsedVal) && parsedVal > 0) movesToMake = parsedVal;\n        }\n        this.displayMessage(`Shuffling ${movesToMake} times...`, \"info\");\n        this.toggleControlButtons(true); this.toggleSquareInteraction(true);\n\n        let successfulMixMoves = 0;\n        let currentFreeSqNum = parseInt(this.freeSquareId.substring(4), 10);\n\n        for (let i = 0; i < movesToMake; i++) {\n            const possibleMovers = POS_ADJACENCY[currentFreeSqNum];\n            if (!possibleMovers || possibleMovers.length === 0) continue;\n            const moverSqNum = possibleMovers[Math.floor(Math.random() * possibleMovers.length)]!;\n\n            const pieceToMoveEl = qs<HTMLLIElement>(`#sq-${moverSqNum}`);\n            const targetFreeEl = qs<HTMLLIElement>(`#sq-${currentFreeSqNum}`);\n            if(pieceToMoveEl && targetFreeEl) {\n                const pieceContent = pieceToMoveEl.firstElementChild;\n                if (pieceContent) targetFreeEl.appendChild(pieceContent);\n                targetFreeEl.classList.remove('free');\n                pieceToMoveEl.classList.add('free');\n                this.freeSquareId = `#${pieceToMoveEl.id}`;\n                currentFreeSqNum = parseInt(this.freeSquareId.substring(4), 10);\n                successfulMixMoves++;\n            }\n        }\n        this.updateMovesCounter(successfulMixMoves, 'Mix');\n        this.displayMessage(`Shuffled ${successfulMixMoves} times. Good luck!`, \"info\");\n        this.toggleControlButtons(false);\n        this.toggleSquareInteraction(false);\n        this.currentMoves = 0;\n    }\n\n    private handleSolveClick(): void {\n        this.displayMessage(\"Solving, please wait...\", \"info\");\n        this.toggleControlButtons(true); this.toggleSquareInteraction(true);\n\n        setTimeout(() => {\n            const currentBoardState = this.getBoardStateFromDOM();\n            if (currentBoardState.includes(null)) {\n                this.displayMessage(\"Error: Invalid board state.\", \"error\");\n                this.toggleControlButtons(false); this.toggleSquareInteraction(false); return;\n            }\n            this.solutionActions = performAStarSearch(currentBoardState, POS_ADJACENCY) || [];\n            if (this.solutionActions.length > 0) {\n                this.displayMessage(`Solution found! Animating ${this.solutionActions.length} moves...`, \"info\");\n                this.animateSolution();\n            } else {\n                if (isBoardSolved(currentBoardState)) this.displayMessage(\"Board is already solved!\", \"success\");\n                else this.displayMessage(\"No solution found.\", \"error\");\n                this.toggleControlButtons(false); this.toggleSquareInteraction(false);\n            }\n        }, 50);\n    }\n\n    private async animateSolution(): Promise<void> {\n        if (this.solutionActions.length === 0) {\n            this.displayMessage(\"No solution to animate or already solved.\", \"info\");\n            this.toggleControlButtons(false); this.toggleSquareInteraction(false); return;\n        }\n        this.toggleSquareInteraction(true);\n\n        let moveIndex = 0;\n        const performNextMove = async (): Promise<void> => {\n            if (moveIndex >= this.solutionActions.length) {\n                this.displayMessage(\"Animation complete!\", \"success\");\n                this.solutionActions = [];\n                if (isBoardSolved(this.getBoardStateFromDOM())) {\n                    await this.triggerWinAnimation();\n                } else {\n                    this.toggleControlButtons(false); this.toggleSquareInteraction(false);\n                }\n                return;\n            }\n            const action = this.solutionActions[moveIndex];\n            if (!action) {\n                console.error(\"Animation Error: Undefined action.\"); this.displayMessage(\"Animation error.\", \"error\");\n                this.toggleControlButtons(false); this.toggleSquareInteraction(false); return;\n            }\n            const pieceSquareIdToMove = `#sq-${getSquareNumberFromIndex(action.fromIndex)}`;\n            const targetEmptySquareId = `#sq-${getSquareNumberFromIndex(action.toIndex)}`;\n\n            if (this.freeSquareId !== targetEmptySquareId) {\n                console.error(`Animation Error: Mismatch. UI free: ${this.freeSquareId}, Action target: ${targetEmptySquareId}`, action);\n                this.displayMessage(\"Animation state error.\", \"error\");\n                this.toggleControlButtons(false); this.toggleSquareInteraction(false); return;\n            }\n\n            await this.movePieceOnDOM(pieceSquareIdToMove, targetEmptySquareId);\n            this.updateMovesCounter(moveIndex + 1, 'Bot');\n\n            moveIndex++;\n            setTimeout(performNextMove, this.animationDuration + 100);\n        };\n        await performNextMove();\n    }\n}\n","import { onDocumentReady } from './domUtils';\nimport { GameUIController } from './gameUI';\n\n/**\n * Main entry point for the 8-Puzzle application.\n */\nonDocumentReady(() => {\n  new GameUIController();\n});\n\n\n"],"names":["onDocumentReady","fn","qs","selector","qsa","NUM_SQUARES","GOAL_STATE","POS_ADJACENCY","isSolved","boardState","i","getSquareNumberFromIndex","index0","getIndexFromSquareNumber","squareNumber1","getManhattanDistance","goalState","numSquares","totalDistance","dimension","tileValue","currentRow","currentCol","targetIndex","targetRow","targetCol","_createSearchNode","state","parent","action","g","h","areArraysEqual","arr1","arr2","reconstructPath","node","path","currentNode","isSolvable","tiles","tile","inversions","j","performAStarSearch","initialState","adjacencyMap","openSet","closedSet","MAX_ITERATIONS","iterations","a","b","emptyIdx","emptySquareNumber","movablePieceSquareNumbers","movablePieceSquareNum","pieceToMoveIndex","tileValueMoved","neighborState","neighborStateStr","gScore","hScore","fScore","existingNodeInOpenSetIndex","openNode","existingNode","neighborNode","GameUIController","_a","_b","square","lastSquareSelector","lastSquareElement","disabled","sourceSquareDomId","targetSquareDomId","currentBoardState","isBoardSolved","text","_type","count","context","pieceSquareIdToMove","targetFreeSquareId","movingSquareEl","targetSquareEl","movingPieceContentEl","resolve","movingRect","targetRect","dx","dy","onTransitionEnd","event","clickedSquareElement","clickedSquareIdNumStr","freeSquareIdNumStr","clickedSquareIdNum","freeSquareIdNum","squareLi","pieceDiv","squareSelector","pieceElement","pieceNumStr","movesToMake","parsedVal","successfulMixMoves","currentFreeSqNum","possibleMovers","moverSqNum","pieceToMoveEl","targetFreeEl","pieceContent","moveIndex","performNextMove","targetEmptySquareId"],"mappings":"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"}